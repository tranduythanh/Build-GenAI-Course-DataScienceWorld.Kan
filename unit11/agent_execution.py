from typing import List, Dict, Any, Optional
from llama_index.core.agent import ReActAgent
from llama_index.core.tools import BaseTool
from llama_index.llms.openai import OpenAI
from llama_index.core.memory import ChatMemoryBuffer
from llama_index.core import Settings

class ExecutionAgent:
    """Specialized agent for coordinating tool execution based on strategic plans"""
    
    def __init__(self, tools: List[BaseTool], api_key: str, tool_outputs_storage: Dict[str, Any] = None) -> None:
        self.llm: OpenAI = OpenAI(api_key=api_key)
        self.tools = tools
        
        # Execution state
        self.current_execution: Optional[Dict[str, Any]] = None
        self.execution_results: List[Dict[str, Any]] = []
        
        # Reference to shared tool outputs storage
        self.tool_outputs_storage = tool_outputs_storage or {}
        
        # System prompt for execution specialist  
        execution_prompt = """B·∫°n l√† Execution Agent chuy√™n nghi·ªáp cho vi·ªác th·ª±c hi·ªán ph√¢n t√≠ch c·ªï phi·∫øu Vi·ªát Nam.

CORE COMPETENCIES:
üöÄ **PLAN EXECUTION**: Th·ª±c hi·ªán strategic plans m·ªôt c√°ch systematic
üîß **TOOL COORDINATION**: Coordinate multiple tools hi·ªáu qu·∫£
üìä **DATA SYNTHESIS**: T·ªïng h·ª£p results t·ª´ multiple sources
üéØ **GOAL ACHIEVEMENT**: Focus v√†o achieving plan objectives

EXECUTION METHODOLOGY:
1. **Plan Interpretation**: Hi·ªÉu r√µ plan requirements v√† sequence
2. **Tool Selection**: Ch·ªçn ƒë√∫ng tools cho t·ª´ng step
3. **Parameter Optimization**: Optimize tool parameters cho best results
4. **Result Integration**: T√≠ch h·ª£p v√† synthesize multiple results
5. **Quality Assurance**: Ensure results meet plan criteria

AVAILABLE TOOLS:
- get_stock_price: L·∫•y d·ªØ li·ªáu gi√° c·ªï phi·∫øu Vi·ªát Nam v·ªõi AI analysis
- calculate_technical_indicators: Ph√¢n t√≠ch k·ªπ thu·∫≠t (SMA, RSI, MACD, Bollinger Bands)

MANDATORY EXECUTION RULES:
üî• **ALWAYS USE TOOLS**: B·∫°n PH·∫¢I s·ª≠ d·ª•ng available tools ƒë·ªÉ l·∫•y d·ªØ li·ªáu th·ª±c
üî• **NO THEORETICAL RESPONSES**: KH√îNG BAO GI·ªú tr·∫£ l·ªùi l√Ω thuy·∫øt m√† kh√¥ng c√≥ d·ªØ li·ªáu th·ª±c
üî• **TOOL-DRIVEN ANALYSIS**: M·ªçi ph√¢n t√≠ch ph·∫£i d·ª±a tr√™n k·∫øt qu·∫£ t·ª´ tools
üî• **DATA REQUIREMENT**: V·ªõi m·ªçi c√¢u h·ªèi v·ªÅ stock, B·∫ÆT BU·ªòC ph·∫£i g·ªçi get_stock_price
üî• **TECHNICAL ANALYSIS**: V·ªõi m·ªçi y√™u c·∫ßu technical indicators, B·∫ÆT BU·ªòC ph·∫£i g·ªçi calculate_technical_indicators

EXECUTION PRINCIPLES:
- ALWAYS call appropriate tools FIRST ƒë·ªÉ l·∫•y d·ªØ li·ªáu
- Follow plan sequence ch√≠nh x√°c v·ªõi REAL DATA
- Validate results at each step
- Provide detailed progress feedback based on ACTUAL RESULTS
- Synthesize comprehensive final output from TOOL OUTPUTS
- Handle errors gracefully v·ªõi fallback strategies

RESPONSE FORMAT:
1. Determine required tools based on query/plan
2. Execute tools with appropriate parameters 
3. INCLUDE FULL TOOL OUTPUTS trong response (b·∫£ng stock prices + technical indicators)
4. Analyze ACTUAL results from tools
5. Provide insights based on REAL DATA v·ªõi references ƒë·∫øn c·ª• th·ªÉ t·ª´ng ch·ªâ s·ªë
6. Give recommendations based on CONCRETE FINDINGS

üî• CRITICAL OUTPUT REQUIREMENTS:
- B·∫ÆT BU·ªòC copy nguy√™n vƒÉn b·∫£ng "Recent 10 Trading Days" t·ª´ get_stock_price
- B·∫ÆT BU·ªòC copy nguy√™n vƒÉn b·∫£ng "Recent 5 Days Technical Indicators" t·ª´ calculate_technical_indicators  
- B·∫ÆT BU·ªòC show Latest Technical Indicators v·ªõi s·ªë li·ªáu c·ª• th·ªÉ
- User ph·∫£i th·∫•y ƒë∆∞·ª£c RAW DATA, kh√¥ng ch·ªâ summary

Focus on efficient, accurate execution theo strategic plan v·ªõi FULL DATA DISPLAY t·ª´ tools."""

        # Initialize memory for execution context
        self.memory = ChatMemoryBuffer.from_defaults(token_limit=2000)
        
        # Initialize agent with tools
        self.agent: ReActAgent = ReActAgent.from_tools(
            tools=tools,
            llm=self.llm,
            memory=self.memory,
            verbose=True,
            system_prompt=execution_prompt
        )
        
        # Hook into agent's tool execution to capture outputs
        self._setup_tool_capture()
    
    def _setup_tool_capture(self) -> None:
        """Setup tool output capture by wrapping tools"""
        for tool in self.tools:
            original_call = tool.__call__
            
            def captured_call(input_data, tool_ref=tool, original_method=original_call):
                # Call original tool
                result = original_method(input_data)
                
                # Store the output for later use
                tool_name = tool_ref.metadata.name
                self.tool_outputs_storage[tool_name] = {
                    "input": input_data,
                    "output": result,
                    "content": result.content if hasattr(result, 'content') else str(result)
                }
                
                return result
            
            # Replace the tool's call method
            tool.__call__ = captured_call
    
    def execute_plan(self, plan: Dict[str, Any], user_query: str) -> Dict[str, Any]:
        """Execute a strategic plan step by step"""
        
        if not plan or plan.get("status") == "failed":
            return {"error": "Invalid or failed plan provided"}
        
        # Initialize execution
        self.current_execution = {
            "plan": plan,
            "query": user_query,
            "status": "executing",
            "current_step": 0,
            "results": []
        }
        
        # Execute based on plan
        execution_prompt = f"""
STRATEGIC PLAN TO EXECUTE:
{plan.get('analysis', '')}

USER QUERY: "{user_query}"
EXTRACTED STEPS: {plan.get('steps', [])}

üî• MANDATORY EXECUTION REQUIREMENTS:
1. B·∫ÆT BU·ªòC ph·∫£i s·ª≠ d·ª•ng get_stock_price tool ƒë·ªÉ l·∫•y d·ªØ li·ªáu c·ªï phi·∫øu th·ª±c
2. B·∫ÆT BU·ªòC ph·∫£i s·ª≠ d·ª•ng calculate_technical_indicators cho M·ªåI c√¢u h·ªèi technical analysis
3. KH√îNG BAO GI·ªú tr·∫£ l·ªùi l√Ω thuy·∫øt m√† kh√¥ng c√≥ d·ªØ li·ªáu t·ª´ tools
4. M·ªçi ph√¢n t√≠ch ph·∫£i d·ª±a tr√™n k·∫øt qu·∫£ TH·ª∞C t·ª´ tool execution

‚ö†Ô∏è TECHNICAL ANALYSIS DETECTION:
Keywords requiring calculate_technical_indicators: RSI, SMA, MACD, Bollinger, ch·ªâ s·ªë k·ªπ thu·∫≠t, technical analysis, ph√¢n t√≠ch k·ªπ thu·∫≠t

EXECUTION STEPS:
1. Identify symbol t·ª´ user query (VIC, FPT, VNM, HAG, MSN, VNINDEX, etc.)
2. MANDATORY STEP 1: call get_stock_price v·ªõi symbol v√† date range ‚Üí L·∫•y d·ªØ li·ªáu 10 ng√†y g·∫ßn nh·∫•t
3. MANDATORY STEP 2: call calculate_technical_indicators v·ªõi c√πng symbol ‚Üí L·∫•y RSI, SMA, MACD, Bollinger Bands
4. ANALYZE & SYNTHESIZE: K·∫øt h·ª£p k·∫øt qu·∫£ t·ª´ c·∫£ hai tools
5. COMPREHENSIVE INSIGHTS: Ph√¢n t√≠ch price trends + technical signals + recommendations  
6. SPECIFIC REFERENCES: ƒê·ªÅ c·∫≠p c·ª• th·ªÉ ƒë·∫øn t·ª´ng ch·ªâ s·ªë TA trong analysis

üî• LU√îN LU√îN G·ªåI C·∫¢ HAI TOOLS:
- get_stock_price ‚Üí Stock price data + 10 recent days
- calculate_technical_indicators ‚Üí RSI, SMA, MACD, Bollinger Bands

üìä MANDATORY OUTPUT INCLUSION:
- Copy b·∫£ng "Recent 10 Trading Days" t·ª´ get_stock_price output
- Copy b·∫£ng "Recent 5 Days Technical Indicators" t·ª´ calculate_technical_indicators output
- Copy "Latest Technical Indicators" v·ªõi t·∫•t c·∫£ s·ªë li·ªáu (Price, SMA, RSI, MACD)
- Show performance metrics n·∫øu c√≥

üìù REQUIRED RESPONSE FORMAT:
```
## üìä STOCK PRICE DATA
[Copy nguy√™n vƒÉn b·∫£ng Recent 10 Trading Days t·ª´ get_stock_price]

## üìà TECHNICAL ANALYSIS  
[Copy nguy√™n vƒÉn Latest Technical Indicators + Recent 5 Days Technical Indicators t·ª´ calculate_technical_indicators]

## üí° ANALYSIS & INSIGHTS
[Ph√¢n t√≠ch d·ª±a tr√™n d·ªØ li·ªáu c·ª• th·ªÉ tr√™n]
```

üöÄ B·∫ÆT ƒê·∫¶U EXECUTION - CALL BOTH TOOLS V√Ä INCLUDE FULL DATA THEO FORMAT!
"""
        
        try:
            response = self.agent.chat(execution_prompt)
            
            # Store execution results
            execution_result = {
                "plan_executed": plan,
                "execution_response": response.response,
                "status": "completed",
                "query": user_query
            }
            
            self.execution_results.append(execution_result)
            self.current_execution["status"] = "completed"
            
            return execution_result
            
        except Exception as e:
            error_result = {
                "error": f"Execution failed: {str(e)}",
                "plan": plan,
                "query": user_query,
                "status": "failed"
            }
            
            self.execution_results.append(error_result)
            if self.current_execution:
                self.current_execution["status"] = "failed"
            
            return error_result
    
    def execute_step(self, step_description: str, context: Dict[str, Any] = None) -> Dict[str, Any]:
        """Execute a single step with context"""
        
        step_prompt = f"""
STEP TO EXECUTE: {step_description}
CONTEXT: {context if context else "No additional context"}
PREVIOUS RESULTS: {self.execution_results[-3:] if self.execution_results else "None"}

Execute this specific step:
1. Analyze step requirements
2. Select appropriate tool(s)
3. Execute with optimal parameters
4. Validate and format results
5. Provide step completion summary

Focus on accurate execution c·ªßa step n√†y.
"""
        
        try:
            response = self.agent.chat(step_prompt)
            
            step_result = {
                "step": step_description,
                "result": response.response,
                "context": context,
                "status": "completed"
            }
            
            # Update current execution if active
            if self.current_execution:
                self.current_execution["results"].append(step_result)
                self.current_execution["current_step"] += 1
            
            return step_result
            
        except Exception as e:
            return {
                "step": step_description,
                "error": f"Step execution failed: {str(e)}",
                "status": "failed"
            }
    
    def synthesize_results(self, results: List[Dict[str, Any]], original_query: str) -> Dict[str, Any]:
        """Synthesize multiple execution results into comprehensive response"""
        
        synthesis_prompt = f"""
ORIGINAL USER QUERY: "{original_query}"
EXECUTION RESULTS: {results}

Synthesize comprehensive final response:

1. **EXECUTIVE SUMMARY**: Key findings v√† insights
2. **DETAILED ANALYSIS**: Breakdown of all results
3. **PRACTICAL RECOMMENDATIONS**: Actionable advice cho user
4. **RISK ASSESSMENT**: Important caveats v√† limitations
5. **NEXT STEPS**: Suggested follow-up actions

T·∫°o professional, comprehensive response t√≠ch h·ª£p all execution results.
Focus on value delivery cho Vietnamese stock market context.
"""
        
        try:
            response = self.agent.chat(synthesis_prompt)
            
            return {
                "synthesis": response.response,
                "original_query": original_query,
                "results_count": len(results),
                "status": "completed"
            }
            
        except Exception as e:
            return {
                "error": f"Synthesis failed: {str(e)}",
                "original_query": original_query,
                "status": "failed"
            }
    
    def get_execution_status(self) -> Optional[Dict[str, Any]]:
        """Get current execution status"""
        return self.current_execution
    
    def get_execution_history(self) -> List[Dict[str, Any]]:
        """Get history of all executions"""
        return self.execution_results
    
    def clear_execution_memory(self) -> None:
        """Clear execution memory and state"""
        try:
            self.agent.reset()
            self.current_execution = None
            self.execution_results = []
        except AttributeError:
            pass 